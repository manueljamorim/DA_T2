#include <list>
#include <vector>

using namespace std;

class Graph {
private:
    struct Edge {
        int src; // Source node
        int dest; // Destination node
        int capacity; // Capacity of the vehicle
        int duration; // Duration of the travel
        int flow; // Flow going through the edge
    };

    struct Node {
        int parent; // The parent node
        vector<Edge> adj; // The list of outgoing vehicles (to adjacent places)
        bool visited; // Has the place been visited on a search?
        int pred;
        int dist;
        int cap;
        vector<int> pred_v;
    };

    int n; // Graph size (vertices are numbered from 1 to n)
    int s, t; // Source node and destination/sink node
    bool hasDir; // false: undirect; true: directed
    vector<Node> nodes; // The list of nodes being represented
    
    bool solved = false; // Indicate whether the algorithm has ran. The result in successive runs will always be the same
    int maxFlow = 0; // Maximum flow. Calculated by calling the solve method

public:
    // Constructor: nr nodes and direction (default: undirected)
    Graph(int nodes, bool dir = false);
    // Add edge from source to destination with a certain weight
    void addEdge(int src, int dest, int capacity, int duration, int flow = 0, bool fromOutput = false);


// ----------------- Task 1 Functions -------------------
    list<int> get_path(int a, int b);

    int max_capacity(int a, int b);

    int min_transbordos(int a, int b);

    int max_capacity_multiple_solutions(int a, int b);

    list<list<int>> get_path_multiple_solutions(int a, int b);

    int recursive(int a, int current);
// ------------------------------------------------------


// ----------------- Task 2 Functions -------------------
    // 2.1
    // Calls solve with the specified group size that we want to determine a path for
    bool calculatePathForGroup(int size);

    // 2.2
    // Calls solve twice: once with the specified group size that we want to determine a path for
    // and again with the increased group size
    // Finally calls printChanges() to output any changes between the paths
    void calculatePathsForGroupIncrease(int increment, int startSize);
    void printChanges(Graph graph1, Graph graph2);

    // 2.3
    // Calls solve with no specified size in order to determine the max flow
    int getMaxFlow();

    int bfs(ofstream& output, int& maxSize);

    int remainingCapacity(Edge e);

    void augmentEdge(Edge& e, int limit);

    // If no maxSize is specified, it simply calculates the max flow of the network
    bool solve(int maxSize = INT_MAX);

    void printOutput();

// ------------------------------------------------------
};

// Creates a graph from a given input file
Graph createGraphFromFile(string filename);

// Creates a graph from the output file generated by the Edmonds-Karp algorithm
Graph createGraphFromOutput();
